package com.akka.cluster.persistence.repository.common

import com.akka.cluster.persistence.model.{Entity, InsertDocumentFailed}
import reactivemongo.bson.{BSONDocument, BSONDocumentReader, BSONDocumentWriter, BSONObjectID}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

trait CRUDOps[T <: Entity] {
  self: Repository[T] =>

  def insert(element: T)(implicit b: BSONDocumentWriter[T]): Future[BSONObjectID] = {
    //TODO find the way to return the id generated by mongo
    collection.flatMap(_.insert(element)).map{ r =>
      r.ok match {
        case true => element._id
        case false => throw InsertDocumentFailed()
      }
    }
  }

  def findAll(implicit b: BSONDocumentReader[T]): Future[List[T]] = {
    collection.flatMap(_.find(BSONDocument.empty).cursor[T]().collect[List]())
  }

  def findOne(id: String)(implicit b: BSONDocumentReader[T]) : Future[Option[T]] = {
    collection.flatMap(_.find(BSONDocument("_id" -> BSONObjectID(id))).one[T])
  }

  def update(id: String, element: T)(implicit b: BSONDocumentWriter[T]): Future[Boolean] = {
    collection.flatMap(_.update(BSONDocument("_id" -> BSONObjectID(id)), element)).map(_.ok)
  }

  def remove(id: String)(implicit b: BSONDocumentWriter[T]): Future[Boolean] = {
    collection.flatMap(_.remove(BSONDocument("_id" -> BSONObjectID(id)))).map(_.ok)
  }

}
